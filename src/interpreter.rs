mod comments;
mod linecontext;
mod operation;
mod types;

use comments::strip_comments;
use linecontext::LineContext;
use types::Type;

use operation::Operation;
use std::{collections::HashMap, num::IntErrorKind};

/// The main interpreter struct which contains the state of the interpreter
pub struct Interpreter {
    stack: Vec<Type>,
    names: HashMap<String, Type>,
}

impl Interpreter {
    pub fn run(source: String) -> Result<(), ()> {
        let mut s = Self {
            stack: Vec::new(),
            names: HashMap::new(),
        };

        s.eval(source)
    }

    fn eval(&mut self, source: String) -> Result<(), ()> {
        for (line_number, line) in source.lines().enumerate() {
            self.eval_line(line, line_number)?;
        }
        Ok(())
    }

    fn eval_line(&mut self, line: &str, line_number: usize) -> Result<(), ()> {
        let line = strip_comments(line);
        Ok(())
    }

    fn eval_operations(
        &mut self,
        operations: Vec<Operation>,
        line_context: LineContext,
    ) -> Result<(), ()> {
        for operation in operations.iter() {
            match operation {
                Operation::StoreName(name) => self.store_name(name, line_context)?,
                Operation::PushName(name) => self.push_name(name, line_context)?,
                Operation::PushConst(cnst) => self.push_const(cnst)?,
                Operation::BinaryAdd => self.binary_add(line_context)?,
                Operation::BinarySub => self.binary_sub(line_context)?,
                Operation::BinaryMul => self.binary_mul(line_context)?,
                Operation::BinaryDiv => self.binary_div(line_context)?,
                Operation::BinaryMod => self.binary_mod(line_context)?,
                _ => {}
            }
        }
        Ok(())
    }
}

// Operation implementations
impl Interpreter {
    fn store_name(&mut self, name: &str, line_context: LineContext) -> Result<(), ()> {
        // Unwrap is safe because operations are generated by the interpreter and verified before this line
        let value = self.stack.pop().unwrap();
        match self.names.get(name) {
            Some(v) => {
                // Compare the two enum values and not the values that are contained within those enums
                if std::mem::discriminant(v) == std::mem::discriminant(&value) {
                    self.names.insert(name.to_string(), value);
                    Ok(())
                } else {
                    error!(
                        "Incorrect type when assigning to variable \"{}\" line:{}",
                        name, line_context.line_number
                    );
                    Err(())
                }
            }
            None => {
                self.names.insert(name.to_string(), value);
                Ok(())
            }
        }
    }

    fn push_name(&mut self, name: &str, line_context: LineContext) -> Result<(), ()> {
        match self.names.get(name) {
            Some(v) => {
                self.stack.push(v.clone());
                Ok(())
            }
            None => {
                error!(
                    "Undefined variable \"{}\" line:{}",
                    name, line_context.line_number
                );
                Err(())
            }
        }
    }

    fn push_const(&mut self, value: &Type) -> Result<(), ()> {
        self.stack.push(value.clone());
        Ok(())
    }

    fn binary_add(&mut self, line_context: LineContext) -> Result<(), ()> {
        // It's safe to unwrap because the operations are generated by the interpreter and
        // verified elsewhere.
        let left = self.stack.pop().unwrap();
        let right = self.stack.pop().unwrap();

        match left {
            Type::Int(left) => match right {
                Type::Int(right) => self.stack.push(Type::Int(left + right)),
                Type::Uint(right) => self.stack.push(Type::Uint(left as u64 + right)),
                Type::F64(right) => self.stack.push(Type::F64(left as f64 + right)),
                Type::Char(right) => self.stack.push(Type::Int(left + right as i64)),
                _ => {
                    error!("Cannot add type Int with {:?}", right);
                    return Err(());
                }
            },
            Type::Uint(left) => match right {
                Type::Int(right) => self.stack.push(Type::Uint(left + right as u64)),
                Type::Uint(right) => self.stack.push(Type::Uint(left + right)),
                Type::F64(right) => self.stack.push(Type::F64(left as f64 + right)),
                Type::Char(right) => self.stack.push(Type::Uint(left + right as u64)),
                _ => {
                    error!("Cannot add type Uint with {:?}", right);
                    return Err(());
                }
            },
            Type::F64(left) => match right {
                Type::Int(right) => self.stack.push(Type::F64(left + right as f64)),
                Type::Uint(right) => self.stack.push(Type::F64(left + right as f64)),
                Type::F64(right) => self.stack.push(Type::F64(left + right)),
                Type::Char(right) => self.stack.push(Type::F64(left + right as f64)),
                _ => {
                    error!("Cannot add type F64 with {:?}", right);
                    return Err(());
                }
            },
            _ => {
                error!("Cannot add type {:?} with {:?}", left, right);
                return Err(());
            }
        }

        Ok(())
    }

    fn binary_sub(&mut self, line_context: LineContext) -> Result<(), ()> {
        Ok(())
    }

    fn binary_mul(&mut self, line_context: LineContext) -> Result<(), ()> {
        Ok(())
    }

    fn binary_div(&mut self, line_context: LineContext) -> Result<(), ()> {
        Ok(())
    }

    fn binary_mod(&mut self, line_context: LineContext) -> Result<(), ()> {
        Ok(())
    }
}

pub fn test_from_main() {
    let operations: Vec<Operation> = vec![
        Operation::PushConst(Type::Int(5)),
        Operation::StoreName("variable0".to_string()),
        Operation::PushConst(Type::Int(100)),
        Operation::StoreName("str".to_string()),
        Operation::PushName("variable0".to_string()),
        Operation::StoreName("str".to_string()),
    ];

    let mut interpreter = Interpreter {
        stack: Vec::new(),
        names: HashMap::new(),
    };

    interpreter.eval_operations(operations, LineContext { line_number: 5 });

    for (key, val) in interpreter.names.iter() {
        println!("{} = {:?}", key, val);
    }
}

#[test]
fn test_eval_operations() {
    // TODO: Implement this test
}
